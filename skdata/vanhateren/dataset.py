"""

NOTES ON THE VAN HATEREN IMAGE DATASET: 
http://bethgelab.org/datasets/vanhateren/
  * Only pixels within a two-pixel wide border around the image are guaranteed
    to be valid
  * Images seem to have a maximum value of 6282.0


Differences between *.imc and *.iml
-----------------------------------

(from http://bethgelab.org/datasets/vanhateren/)

The *.iml image set ('linear') are the raw images produced by the camera,
linearized with the lookup table generated by the camera for each image. The
images are slightly blurred by the point-spread function of the camera (in
particular due to the optics of the lens). For projects where a stricly linear
relationship between scene luminance and pixel values is important (e.g., when
looking at contrast variations over images) this may be the set of choice.

The *.imc image set ('calibrated') is computed from the *.iml set by
deconvolving the images with the point-spread function corresponding to the
used lens aperture (see the methods section of the article cited above). This
strongly reduces the blur at sharp edges and lines. The deconvolution
occasionally leads to overshoots and undershoots; the latter can produce
negative pixel values in a minority of images. For those images this was
compensated by adding a fixed offset to all pixel values of the image. These
offsets are listed below in the IMC offest list. Although they are generally
quite small, they slightly compromise the linearity of the relationship
between scene luminance and pixel value. Therefore this image set is best
suited for projects where well-defined edges are of more importance than
strict linearity.

"""

# Copyright (C) 2012
# Authors: Eric Hunsberger, James Bergstra

# License: Simplified BSD

import hashlib
import os
import numpy as np

from skdata.data_home import get_data_home
from skdata.utils import download

BASE_URL = 'http://pirsquared.org/research/vhatdb/imc/'

class NaturalImages(object):

    imshape = (1024, 1536)

    def __init__(self):
        self.name = self.__class__.__name__

    def home(self, *suffix_paths):
        return os.path.join(get_data_home(), self.name, *suffix_paths)

    def image_basename(ind, calibrated):
        return ('imk%0.5d' % (ind)) + ('.imc' if calibrated else '.iml')

    def fetch(
        self,
        download_if_missing=True,
        calibrated=True,
        n_images_limit=4213,
        ):

        if not download_if_missing:
            return

        if not calibrated:
            raise NotImplementedError()

        if not os.path.exists(self.home()):
            os.makedirs(self.home())

        download(BASE_URL + 'md5sums', self.home('md5sums'))

        for line in open(self.home('md5sums')):
            md5hash, filename = line.strip().split()
            filename = filename[1:]
            if 'HEADER' in filename:
                continue
            try:
                data = open(self.home(filename), 'rb').read()
                if hashlib.md5(data).hexdigest() != md5hash:
                    print 'Re-downloading incorrect file', filename
                    download(BASE_URL + filename,
                             self.home(filename),
                             md5=md5hash)
                    # TODO: catch ctrl-C, check md5,
                    # and remove partial download
            except IOError:
                download(BASE_URL + filename, self.home(filename), md5=md5hash)

    def read_image(self, ind, calibrated=False):
        """
        Read one image from the Van Hateren natural image dataset.

        Returns a (1024, 1536) in the original uint16 dtype
        """
        
        basename = 'imk%0.5d.%s' % (ind, ('.imc' if calibrated else '.iml'))
        filename = os.path.join(self.home(basename))
        s = open(filename, 'rb').read()
        img = np.fromstring(s, dtype='uint16').byteswap()
        img = img.reshape(self.imshape)
        return img


